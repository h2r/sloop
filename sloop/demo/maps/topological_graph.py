from sloop.demo.maps.graph import Node, Graph, Edge
from sloop.demo.utils import euclidean_dist
import json
import yaml
import os
import sys
import random
from collections import deque

class TopoNode(Node):
    def __init__(self, id, grid_pose):
        self.id = id
        self.pose = grid_pose
        self._coords = self.pose  # for visualization
        self._color = "orange"

class TopoMap(Graph):

    @classmethod
    def load(cls, filename):
        with open(filename) as f:
            data = json.load(f)

        nodes = {}
        for node_id in data["nodes"]:
            node_data = data["nodes"][node_id]
            x, y = node_data["x"], node_data["y"]
            nodes[int(node_id)]= TopoNode(int(node_id), (x, y))

        edges = {}
        for i, edge in enumerate(data["edges"]):
            node_id1, node_id2 = edge[0], edge[1]
            n1 = nodes[int(node_id1)]
            n2 = nodes[int(node_id2)]
            edges[i] = Edge(i, n1, n2,
                            data=euclidean_dist(n1.pose, n2.pose))

        return TopoMap(edges)

    def closest_node(self, x, y):
        """Given a point at (x,y) in pomdp grid frame
        find the node that is closest to this point."""
        return min(self.nodes,
                   key=lambda nid: euclidean_dist(self.nodes[nid].pose[:2], (x,y)))

    def navigable(self, nid1, nid2):
        # DFS find path from nid1 to nid2
        stack = deque()
        stack.append(nid1)
        visited = set()
        while len(stack) > 0:
            nid = stack.pop()
            if nid == nid2:
                return True
            for neighbor_nid in self.neighbors(nid):
                if neighbor_nid not in visited:
                    stack.append(neighbor_nid)
                    visited.add(neighbor_nid)
        return False

    def to_json(self):
        result = {"nodes": {}, "edges": []}
        for nid in self.nodes:
            pose = self.nodes[nid].pose
            result["nodes"][nid] = {"x": pose[0], "y": pose[1]}
        for eid in self.edges:
            edge = self.edges[eid]
            node1, node2 = edge.nodes
            result["edges"].append([node1.id, node2.id])
        return result


def rrt_topo(mapinfo, map_name, flight_height=7, init_pos=None, safty_radius=1, num_vertices=30,
             landmark_heights={}, inc_dist=3, seed=100,
             connect_dist_inflation=1.25, streets_only=False):
    """Given mapinfo, output a topological graph that is generated by sampling
    locations on the map satisfying constraints w.r.t. landmarks
    (i.e. obstacles);

    Technically, the topological graph edges can go through buildings that are
    lower (so it's height-dependent), but right now the map info does not have
    height information.  So right now I'll treat them as equal, unless
    `landmark_heights` is supplied, which is a mapping from landmark symbol to
    height.

    `connect_dist_inflation`: Nodes that are within inc_dist * connect_dist_inflation
    """
    def check_valid_pos(pos):
        w, l = mapinfo.map_dims(map_name)
        if 0 <= pos[0] < w and 0 <= pos[1] < l:
            for landmark_symbol in mapinfo.landmarks_for(map_name):
                if landmark_symbol in mapinfo.streets(map_name):
                    continue

                landmark_height = landmark_heights.get(landmark_symbol, 5)
                for loc in mapinfo.landmark_footprint(landmark_symbol, map_name=map_name):
                    #### TODO: THIS THIS BUGGY?
                    if not (euclidean_dist(pos, loc) > safty_radius\
                            and flight_height > landmark_height):
                        return False
            return True
        return False

    w, l = mapinfo.map_dims(map_name)

    # config space
    configs = set((x,y)
                  for x in range(w) for y in range(l))
    visited = set()

    # the graph
    nodes = {}
    edges = {}

    # deterministic
    rnd = random.Random(seed)

    while True:
        sys.stdout.write("Finding [%d/%d] vertices\r" % (len(nodes), num_vertices))
        sys.stdout.flush()

        # sample from configuration space
        if len(nodes) == 0 and init_pos is not None:
            x, y = init_pos
        else:
            x, y = rnd.sample(configs, 1)[0]

        if len(nodes) == 0:
            new_node = TopoNode(0, (x, y))
            nodes[new_node.id] = new_node
            visited.add((x,y))
        else:
            nearest_nid = min(nodes, key=lambda nid: euclidean_dist(nodes[nid].pose[:2], (x,y)))
            nearest_node = nodes[nearest_nid]
            nearest_x, nearest_y = nearest_node.pose[:2]

            dist = euclidean_dist(nearest_node.pose[:2], (x,y))
            if dist == 0 or dist < inc_dist:
                continue
            new_x = int(round(nearest_x + (inc_dist / dist) * (x - nearest_x)))
            new_y = int(round(nearest_y + (inc_dist / dist) * (y - nearest_y)))
            if (new_x, new_y) in visited:
                continue
            if streets_only:
                if mapinfo.landmark_at(map_name, (new_x, new_y))\
                   not in mapinfo.streets(map_name):
                    continue

            if check_valid_pos((new_x, new_y)):
                new_node = TopoNode(len(nodes), (new_x, new_y))
                nodes[new_node.id] = new_node
                edge = Edge(len(edges), nearest_node, new_node)
                edges[edge.id] = edge
                visited.add((new_x, new_y))

        if len(nodes) >= num_vertices:
            break
    sys.stdout.write("\n")
    sys.stdout.flush()

    # Make more connections
    for nid1 in nodes:
        for nid2 in nodes:
            if nid1 == nid2:
                continue
            pos1 = nodes[nid1].pose
            pos2 = nodes[nid2].pose
            mid_pos = ((pos1[0] + pos2[0])/2, (pos1[1] + pos2[1])/2)
            if check_valid_pos(mid_pos):
                if euclidean_dist(pos1, pos2) <= inc_dist*connect_dist_inflation:
                    edge = Edge(len(edges), nodes[nid1], nodes[nid2])
                    edges[edge.id] = edge
    return TopoMap(edges)
